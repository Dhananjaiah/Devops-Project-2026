# S2.3: Terraform Module Skeleton

**Video Duration:** ~8 minutes  
**Story Points:** 2

---

## Learning Objectives

By the end of this video, you will be able to:
- Create reusable Terraform modules
- Understand module structure best practices
- Set up module input/output interfaces
- Create environment configurations

---

## Transcript

### Introduction (0:00 - 0:45)

Welcome back! Now that we have our bootstrap in place, let's create the module structure that will hold all our infrastructure code.

Terraform modules are like functions in programming - they take inputs, do something, and produce outputs. We'll create reusable modules for VPC, EKS, and ECR.

### Module Structure (0:45 - 2:00)

Here's our folder structure:

```
techitfactory-infra/
├── bootstrap/         # What we already built
├── modules/
│   ├── vpc/          # Virtual Private Cloud
│   ├── eks/          # Elastic Kubernetes Service
│   └── ecr/          # Elastic Container Registry
└── environments/
    ├── dev/          # Development environment
    └── prod/         # Production environment
```

Each module has three files:
- `main.tf` - Resource definitions
- `variables.tf` - Input variables
- `outputs.tf` - Output values

Environment folders call these modules with different configurations.

### Creating the VPC Module Skeleton (2:00 - 4:00)

Let me create the VPC module:

```bash
mkdir -p modules/vpc
```

*[Creates variables.tf]*

```hcl
variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
}

variable "vpc_cidr" {
  description = "CIDR block for VPC"
  type        = string
  default     = "10.0.0.0/16"
}

variable "availability_zones" {
  description = "List of availability zones"
  type        = list(string)
  default     = ["ap-south-1a", "ap-south-1b"]
}
```

Notice how I'm defining sensible defaults but allowing overrides. This is the interface to our module.

*[Creates outputs.tf]*

```hcl
output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}

output "private_subnet_ids" {
  description = "IDs of private subnets"
  value       = aws_subnet.private[*].id
}

output "public_subnet_ids" {
  description = "IDs of public subnets"
  value       = aws_subnet.public[*].id
}
```

Outputs are how other modules consume our VPC data. EKS will need these subnet IDs!

### Creating Environment Configuration (4:00 - 6:00)

Now let's set up the dev environment:

```bash
mkdir -p environments/dev
```

*[Creates environments/dev/main.tf]*

```hcl
terraform {
  backend "s3" {
    bucket         = "techitfactory-terraform-state-ACCOUNT_ID"
    key            = "dev/terraform.tfstate"
    region         = "ap-south-1"
    dynamodb_table = "techitfactory-terraform-locks"
    encrypt        = true
  }
}

provider "aws" {
  region = "ap-south-1"
  
  default_tags {
    tags = {
      Project     = "techitfactory"
      Environment = "dev"
      ManagedBy   = "terraform"
    }
  }
}

module "vpc" {
  source = "../../modules/vpc"
  
  project_name = "techitfactory"
  environment  = "dev"
  vpc_cidr     = "10.0.0.0/16"
}
```

See how the environment calls the module? It passes specific values for dev. Prod would use different values.

### Module Best Practices (6:00 - 7:30)

A few best practices I'm following:

**1. Default Tags**: I'm using `default_tags` in the provider so every resource gets tagged automatically.

**2. Consistent Naming**: All resources use `${var.project_name}-${var.environment}` prefix.

**3. Outputs First**: I design outputs before implementation - what will consumers need?

**4. Type Constraints**: Every variable has a type (string, list, map).

**5. Descriptions**: Every variable and output has a description for documentation.

### Summary (7:30 - 8:00)

We've set up:
1. Module folder structure (vpc, eks, ecr)
2. Standard file organization (main, variables, outputs)
3. Environment configuration pattern
4. Best practices for reusability

This skeleton is ready to be filled with actual resources. Next video: VPC Networking!

---

## Key Takeaways

- Modules are reusable infrastructure components
- Each module has main.tf, variables.tf, outputs.tf
- Environments call modules with specific configs
- Default tags eliminate repetitive tagging
- Design outputs based on what consumers need
