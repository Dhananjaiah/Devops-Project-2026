# S9.1: GitHub Actions CI/CD

**Video Duration:** ~12 minutes  
**Story Points:** 5

---

## Learning Objectives

By the end of this video, you will be able to:
- Create unified CI workflow for all services
- Use matrix builds with change detection
- Configure OIDC for keyless AWS access
- Update GitOps repo automatically

---

## Transcript

### Introduction (0:00 - 1:00)

Welcome to Sprint 5! We're automating everything. No more manual docker builds and pushes - GitHub Actions will handle it all.

### Real-World CI Architecture (1:00 - 2:30)

Companies don't have 6 separate CI files for 6 services. They use:

1. **One unified workflow** with change detection
2. **Matrix builds** for parallel execution
3. **Reusable workflows** for shared logic

That's what we'll build.

### Change Detection (2:30 - 4:30)

```yaml
name: CI

on:
  push:
    branches: [main]
    paths:
      - 'services/**'

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            api-gateway:
              - 'services/api-gateway/**'
            product-service:
              - 'services/product/**'
```

The paths-filter action detects which services changed. Only those get built!

### Matrix Builds (4:30 - 6:30)

```yaml
build:
  needs: detect-changes
  strategy:
    matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
  
  steps:
    - name: Build and push
      uses: docker/build-push-action@v5
      with:
        context: ${{ matrix.path }}
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ matrix.service }}:${{ github.sha }}
```

Matrix builds run in parallel. If api-gateway and frontend changed, both build simultaneously!

### OIDC Authentication (6:30 - 8:00)

Remember our GitHub OIDC provider from Sprint 1? Here's how to use it:

```yaml
jobs:
  build:
    permissions:
      id-token: write  # Required!
      contents: read
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-south-1
```

No access keys needed! The workflow gets temporary credentials via OIDC.

### GitOps Update (8:00 - 10:00)

After build, update the GitOps repo:

```yaml
update-gitops:
  needs: build
  steps:
    - uses: actions/checkout@v4
      with:
        repository: TechITFactory/techitfactory-gitops
        token: ${{ secrets.GITOPS_TOKEN }}
    
    - name: Update image tag
      run: |
        cd environments/dev/${{ matrix.service }}
        sed -i "s|newTag:.*|newTag: ${{ github.sha }}|" kustomization.yaml
    
    - name: Commit and push
      run: |
        git config user.name "GitHub Actions Bot"
        git add .
        git commit -m "Update ${{ matrix.service }} to ${{ github.sha }}"
        git push
```

ArgoCD detects the change and deploys automatically!

### Testing the Pipeline (10:00 - 11:30)

```bash
cd techitfactory-app

# Change just one service
echo "// test" >> services/api-gateway/src/index.js

git add . && git commit -m "test: trigger CI" && git push
```

*[Shows GitHub Actions running]*

Only api-gateway is building, not all 6 services!

*[Shows GitOps update, then ArgoCD sync]*

### Summary (11:30 - 12:00)

We built:
1. Unified CI for all services
2. Change detection - only build what changed
3. Matrix builds for parallelism
4. OIDC authentication - no secrets
5. Automatic GitOps updates

Next: Optional code quality with SonarCloud!

---

## Key Takeaways

- One workflow, six services
- Change detection saves CI minutes
- Matrix builds run in parallel
- OIDC is more secure than access keys
- GitOps update triggers ArgoCD
