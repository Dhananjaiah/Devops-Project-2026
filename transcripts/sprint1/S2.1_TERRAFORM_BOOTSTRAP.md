# S2.1: Terraform Bootstrap (S3, DynamoDB, KMS)

**Video Duration:** ~12 minutes  
**Story Points:** 3

---

## Learning Objectives

By the end of this video, you will be able to:
- Set up Terraform remote state with S3
- Configure state locking with DynamoDB
- Enable encryption with KMS
- Understand why remote state is critical

---

## Transcript

### Introduction (0:00 - 1:00)

Welcome back! This is one of the most important videos in the entire course. We're setting up the Terraform bootstrap - the foundation that everything else builds on.

Here's the chicken-and-egg problem: Terraform needs somewhere to store its state, but we need Terraform to create that storage. So we bootstrap with local state first, then migrate.

Let's dive in!

### Why Remote State? (1:00 - 2:00)

By default, Terraform stores state in a local file called `terraform.tfstate`. This is fine for learning, but terrible for production. Here's why:

**Problem 1: Collaboration**. If state is on your laptop, your teammate can't run Terraform. You'll overwrite each other's changes.

**Problem 2: State loss**. Laptop dies? State is gone. Your infrastructure is orphaned.

**Problem 3: No locking**. Two people run Terraform simultaneously? Corrupted state.

The solution: Store state in S3 with DynamoDB locking and KMS encryption.

### The Bootstrap Architecture (2:00 - 3:00)

Here's what we're creating:

1. **S3 Bucket** - Stores the state file, versioned so we can recover
2. **DynamoDB Table** - Provides locking so only one person runs at a time
3. **KMS Key** - Encrypts the state file (contains sensitive data!)

Let me show you the code.

### Walking Through main.tf (3:00 - 6:00)

*[Opens techitfactory-infra/bootstrap/main.tf]*

```hcl
terraform {
  required_version = ">= 1.5.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
```

We start with version constraints. Always pin your provider versions in production!

```hcl
resource "aws_s3_bucket" "terraform_state" {
  bucket = "techitfactory-terraform-state-${data.aws_caller_identity.current.account_id}"
  
  lifecycle {
    prevent_destroy = true
  }
}
```

The bucket name includes the account ID to ensure uniqueness. The `prevent_destroy` lifecycle rule means Terraform will refuse to delete this bucket - that's intentional protection!

```hcl
resource "aws_s3_bucket_versioning" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id
  versioning_configuration {
    status = "Enabled"
  }
}
```

Versioning is enabled. If something goes wrong, we can restore previous state versions.

```hcl
resource "aws_dynamodb_table" "terraform_locks" {
  name         = "techitfactory-terraform-locks"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }
}
```

DynamoDB table for locking. PAY_PER_REQUEST means we only pay when locks are acquired - very cost effective.

### Deploying the Bootstrap (6:00 - 8:00)

Let's deploy!

```bash
cd techitfactory-infra/bootstrap

# Initialize Terraform
terraform init

# Preview changes
terraform plan
```

*[Shows plan output]*

You can see it's creating the S3 bucket, DynamoDB table, and KMS key. Everything looks good.

```bash
# Apply the changes
terraform apply
```

*[Types 'yes']*

And there we go! Our bootstrap infrastructure is created.

### Migrating to Remote State (8:00 - 10:00)

Right now, bootstrap itself is using local state. Let's migrate it.

First, add the backend configuration:

```hcl
terraform {
  backend "s3" {
    bucket         = "techitfactory-terraform-state-ACCOUNT_ID"
    key            = "bootstrap/terraform.tfstate"
    region         = "ap-south-1"
    dynamodb_table = "techitfactory-terraform-locks"
    encrypt        = true
  }
}
```

Now run init again:

```bash
terraform init
```

Terraform asks: "Do you want to copy existing state to the new backend?"

*[Types 'yes']*

Now our state is safely stored in S3!

### Verifying (10:00 - 11:00)

Let's verify everything:

```bash
# Check S3
aws s3 ls s3://techitfactory-terraform-state-ACCOUNT_ID/

# Check DynamoDB
aws dynamodb describe-table --table-name techitfactory-terraform-locks

# Try to acquire a lock (will show in DynamoDB)
terraform plan
```

Perfect! You can see the state file in S3 and locks working in DynamoDB.

### Summary (11:00 - 12:00)

Let's recap:

1. Created S3 bucket with versioning for state storage
2. Created DynamoDB table for state locking
3. Created KMS key for encryption
4. Migrated to remote backend

This bootstrap is the foundation for all our Terraform code. Every environment we create will use this remote state.

Next up: GitHub OIDC for keyless authentication!

---

## Key Takeaways

- Remote state enables team collaboration
- S3 versioning allows state recovery
- DynamoDB prevents concurrent modifications
- KMS encryption protects sensitive state data
- Bootstrap uses local state first, then migrates
