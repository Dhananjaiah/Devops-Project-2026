# S1.1: Create 3 GitHub Repositories

**Video Duration:** ~8 minutes  
**Story Points:** 2

---

## Learning Objectives

By the end of this video, you will be able to:
- Create a multi-repo architecture for production DevOps
- Set up proper repository naming conventions
- Configure essential repository settings
- Understand the purpose of each repository

---

## Transcript

### Introduction (0:00 - 0:45)

Hey everyone, welcome to the TechITFactory DevOps course! I'm excited to kick off Sprint 1 with our very first story: creating the three GitHub repositories that will form the foundation of our entire infrastructure.

In production environments, we don't throw everything into a single repository. Instead, we separate concerns using a multi-repo architecture. This gives us better access control, cleaner CI/CD pipelines, and separation of duties between infrastructure, applications, and deployment configurations.

Let's jump right in!

### The Three Repository Architecture (0:45 - 2:00)

So what are these three repositories?

**First, techitfactory-infra.** This is our Infrastructure as Code repository. All our Terraform code lives here - VPC, EKS cluster, ECR repositories, IAM roles - everything that creates and manages AWS resources.

**Second, techitfactory-app.** This is where our application source code lives. We'll have six microservices here - API Gateway, Product Service, Order Service, Cart Service, User Service, and Frontend. Each with its own Dockerfile and source code.

**Third, techitfactory-gitops.** This is our GitOps repository. It contains Kubernetes manifests, Kustomize overlays, and ArgoCD application definitions. ArgoCD watches this repository and automatically deploys changes to our cluster.

This separation is exactly what you'll see at companies like Netflix, Spotify, and Google. It's the industry standard.

### Creating the Infrastructure Repository (2:00 - 3:30)

Let's start by creating our infrastructure repository.

*[Screen shows GitHub]*

I'll click "New repository". For the name, I'm using `techitfactory-infra`. 

For visibility, I'm choosing Private. In production, you definitely want your infrastructure code to be private.

I'll add a README file and select a .gitignore template for Terraform.

*[Clicks Create Repository]*

Now let's set up some essential settings. I'll go to Settings, then Branches.

I'm adding a branch protection rule for `main`. This is critical! I'm requiring:
- Pull request reviews before merging
- Status checks to pass
- No force pushes

This ensures nobody can accidentally push directly to main and break our infrastructure.

### Creating the Application Repository (3:30 - 5:00)

Next, let's create the application repository.

*[Creates techitfactory-app]*

Same process - Private visibility, README, and this time I'll add a Node.js .gitignore since most of our services are Node-based.

For branch protection, same rules apply - require pull requests and status checks.

I'm also going to enable the "Automatically delete head branches" option. This keeps our repository clean by deleting feature branches after they're merged.

### Creating the GitOps Repository (5:00 - 6:30)

Finally, our GitOps repository.

*[Creates techitfactory-gitops]*

This one is interesting because ArgoCD will be watching it. We want automated sync but also some protection.

I'll set up the same branch protection rules, but here's a pro tip: in production, you might want to add CODEOWNERS file so that specific teams must approve changes to certain paths.

### Clone and Verify (6:30 - 7:30)

Now let's clone all three repositories locally.

```bash
mkdir ~/techitfactory && cd ~/techitfactory

git clone git@github.com:TechITFactory/techitfactory-infra.git
git clone git@github.com:TechITFactory/techitfactory-app.git
git clone git@github.com:TechITFactory/techitfactory-gitops.git

ls -la
```

Perfect! We now have all three repositories ready to go.

### Summary (7:30 - 8:00)

Let's recap what we accomplished:

1. Created `techitfactory-infra` for Terraform code
2. Created `techitfactory-app` for microservice source code
3. Created `techitfactory-gitops` for Kubernetes manifests
4. Set up branch protection on all repositories

This multi-repo architecture is the foundation that everything else builds on. In the next video, we'll set up trunk-based development workflow.

See you there!

---

## Key Takeaways

- Multi-repo architecture separates concerns (infra, app, gitops)
- Branch protection prevents accidental direct pushes to main
- Private repositories are essential for production infrastructure
- Each repository has a specific purpose in the deployment pipeline
