# S1.2: Trunk-Based Development Setup

**Video Duration:** ~6 minutes  
**Story Points:** 1

---

## Learning Objectives

By the end of this video, you will be able to:
- Understand trunk-based development vs GitFlow
- Configure short-lived feature branches
- Set up commit conventions
- Implement PR templates

---

## Transcript

### Introduction (0:00 - 0:30)

Welcome back! In this video, we're setting up trunk-based development for our repositories. This is how modern engineering teams at Google, Facebook, and most tech companies work.

If you've used GitFlow before with long-lived develop and release branches, forget all that. Trunk-based development is simpler and faster.

### What is Trunk-Based Development? (0:30 - 1:30)

The concept is simple: everyone works off a single main branch called "trunk" - we call it `main`.

Here's the workflow:
1. Create a short-lived feature branch from main
2. Make your changes
3. Open a pull request
4. Get it reviewed and approved
5. Merge back to main
6. Delete the feature branch

The key word is "short-lived". Feature branches should live for hours or maybe a day or two - not weeks!

Why does this matter? Because long-lived branches lead to massive merge conflicts, integration problems, and deployment nightmares. With trunk-based dev, you're always integrating, always deploying.

### Setting Up Commit Conventions (1:30 - 3:00)

Let's set up conventional commits. This standard helps us:
- Auto-generate changelogs
- Semantic versioning
- Clear commit history

The format is: `type(scope): description`

Types include:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation
- `chore`: Maintenance
- `refactor`: Code restructuring

For example:
```
feat(eks): add cluster autoscaler configuration
fix(api-gateway): resolve memory leak in connection pool
docs(readme): update installation instructions
```

### Creating PR Templates (3:00 - 4:30)

Let me create a pull request template.

*[Creating file]*

```bash
cd techitfactory-infra
mkdir -p .github
```

```markdown
## Description
<!-- What does this PR do? -->

## Type of Change
- [ ] Feature
- [ ] Bug fix
- [ ] Documentation
- [ ] Refactoring

## Checklist
- [ ] I have tested these changes locally
- [ ] I have updated documentation if needed
- [ ] I have added appropriate labels

## Related Issues
<!-- Link any related issues -->
```

This template ensures every PR has the information reviewers need.

### Branch Naming Convention (4:30 - 5:30)

Let's establish branch naming conventions:

- `feature/EKS-123-add-cluster-autoscaler` - for new features
- `fix/EKS-456-memory-leak` - for bug fixes
- `docs/update-readme` - for documentation

The pattern is: `type/ticket-brief-description`

This convention:
- Makes it easy to find branches
- Links to Jira tickets
- Self-documents what the branch contains

### Demo: Full Workflow (5:30 - 6:00)

Let me show a quick example:

```bash
# Start from main
git checkout main
git pull

# Create feature branch
git checkout -b feature/S1-add-terraform-bootstrap

# Make changes...

# Commit with conventional format
git commit -m "feat(bootstrap): add S3 state bucket configuration"

# Push and create PR
git push -u origin feature/S1-add-terraform-bootstrap
```

Then we open a PR, get it reviewed, and merge!

### Summary

That's trunk-based development in action:
- Single main branch
- Short-lived feature branches
- Conventional commits
- PR templates for consistency

Next up, we'll start building our Terraform bootstrap!

---

## Key Takeaways

- Trunk-based dev = single main branch + short-lived feature branches
- Conventional commits enable automation and clear history
- PR templates standardize code review process
- Branch naming links code to tickets
