# S8.2: Production Dockerfiles

**Video Duration:** ~12 minutes  
**Story Points:** 3

---

## Learning Objectives

By the end of this video, you will be able to:
- Write multi-stage Dockerfiles
- Implement security best practices
- Optimize image size
- Create non-root containers

---

## Transcript

### Introduction (0:00 - 1:00)

Welcome back! Let's write Dockerfiles that are actually production-ready. Not those 10-line demos you see in tutorials!

### Multi-Stage Builds (1:00 - 3:00)

Here's our API Gateway Dockerfile:

```dockerfile
# Stage 1: Build
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Stage 2: Production
FROM node:20-alpine AS production
WORKDIR /app

RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup

COPY --from=builder --chown=appuser:appgroup /app/node_modules ./node_modules
COPY --chown=appuser:appgroup . .

ENV NODE_ENV=production
USER appuser
EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s \
  CMD wget -q --spider http://localhost:3000/health || exit 1

CMD ["node", "src/index.js"]
```

Let me explain each part.

### Security: Non-Root User (3:00 - 4:30)

```dockerfile
RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup

USER appuser
```

Never run as root! If the container is compromised, the attacker has limited access.

The `--chown=appuser:appgroup` in COPY ensures files are owned by our non-root user.

### Health Checks (4:30 - 5:30)

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s \
  CMD wget -q --spider http://localhost:3000/health || exit 1
```

Docker itself can check if the container is healthy. Kubernetes uses this for liveness probes.

### Python Service Example (5:30 - 7:30)

```dockerfile
# Order Service (Python)
FROM python:3.11-slim AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --user -r requirements.txt

FROM python:3.11-slim AS production
WORKDIR /app

RUN useradd -m -u 1001 appuser

COPY --from=builder --chown=appuser /root/.local /home/appuser/.local
COPY --chown=appuser . .

ENV PATH=/home/appuser/.local/bin:$PATH
ENV PYTHONUNBUFFERED=1

USER appuser
EXPOSE 8000

HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8000/health || exit 1

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "app.main:app"]
```

Same patterns: multi-stage, non-root, health check.

### Frontend (Nginx) (7:30 - 9:00)

```dockerfile
FROM nginx:alpine

RUN adduser -D -g '' appuser && \
    chown -R appuser:appuser /usr/share/nginx/html

COPY --chown=appuser nginx.conf /etc/nginx/nginx.conf
COPY --chown=appuser public/ /usr/share/nginx/html/

EXPOSE 80

HEALTHCHECK --interval=30s --timeout=3s \
  CMD wget -q --spider http://localhost/health || exit 1

CMD ["nginx", "-g", "daemon off;"]
```

The nginx.conf includes a health endpoint:

```nginx
location /health {
    return 200 'healthy';
    add_header Content-Type text/plain;
}
```

### .dockerignore (9:00 - 10:00)

Don't forget this file:

```
node_modules
.git
*.md
Dockerfile
.dockerignore
.env
```

This prevents copying unnecessary files into the image.

### Building All Services (10:00 - 11:30)

```bash
cd techitfactory-app

for service in api-gateway product order cart user-service frontend; do
  echo "Building $service..."
  docker build -t techitfactory/$service:latest services/$service
done

docker images | grep techitfactory
```

*[Shows image sizes]*

Small images! Alpine base gives us 100-150MB instead of 1GB.

### Summary (11:30 - 12:00)

Production Dockerfile patterns:
1. Multi-stage builds
2. Non-root users
3. Health checks
4. Minimal base images
5. .dockerignore

Next: Helm charts for deployment!

---

## Key Takeaways

- Multi-stage builds keep images small
- Non-root users improve security
- Health checks enable self-healing
- Alpine base images are much smaller
- .dockerignore reduces build context
