name: CD Pipeline

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: ecommerce-cluster
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION || 'us-east-1' }}.amazonaws.com

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    strategy:
      matrix:
        service: [product-service, user-service, cart-service, order-service]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.ECR_REGISTRY }}/${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: ./microservices/${{ matrix.service }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Output image digest
      run: echo "Image pushed with digest ${{ steps.build.outputs.digest }}"

  deploy-to-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-push]
    environment:
      name: staging
      url: https://staging.ecommerce.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
    
    - name: Update image tags in manifests
      run: |
        for service in product-service user-service cart-service order-service; do
          sed -i "s|image: ${service}:latest|image: ${{ env.ECR_REGISTRY }}/${service}:${{ github.sha }}|g" k8s/deployments/${service}.yaml
        done
    
    - name: Deploy to Kubernetes
      run: |
        kubectl apply -f k8s/namespaces/
        kubectl apply -f k8s/rbac/
        kubectl apply -f k8s/databases/
        kubectl apply -f k8s/configmaps/
        kubectl apply -f k8s/deployments/
        kubectl apply -f k8s/services/
        kubectl apply -f k8s/ingress/
        kubectl apply -f k8s/autoscaling/
        kubectl apply -f k8s/network-policies/
    
    - name: Wait for rollout
      run: |
        kubectl rollout status deployment/product-service -n ecommerce --timeout=5m
        kubectl rollout status deployment/user-service -n ecommerce --timeout=5m
        kubectl rollout status deployment/cart-service -n ecommerce --timeout=5m
        kubectl rollout status deployment/order-service -n ecommerce --timeout=5m
    
    - name: Run smoke tests
      run: |
        # Get the LoadBalancer URL
        LB_URL=$(kubectl get ingress ecommerce-ingress -n ecommerce -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Wait for LoadBalancer to be ready
        sleep 30
        
        # Run smoke tests
        curl -f http://${LB_URL}/api/products/health || echo "Product service health check"
        curl -f http://${LB_URL}/api/users/health || echo "User service health check"
        curl -f http://${LB_URL}/api/cart/health || echo "Cart service health check"
        curl -f http://${LB_URL}/api/orders/health || echo "Order service health check"

  deploy-to-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-to-staging]
    environment:
      name: production
      url: https://ecommerce.example.com
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
    
    - name: Blue-Green Deployment - Create Green Environment
      run: |
        # Label current deployment as "blue"
        kubectl label deployment/product-service -n ecommerce version=blue --overwrite
        kubectl label deployment/user-service -n ecommerce version=blue --overwrite
        kubectl label deployment/cart-service -n ecommerce version=blue --overwrite
        kubectl label deployment/order-service -n ecommerce version=blue --overwrite
        
        # Update image tags for green deployment
        for service in product-service user-service cart-service order-service; do
          sed -i "s|image: ${service}:latest|image: ${{ env.ECR_REGISTRY }}/${service}:${{ github.ref_name }}|g" k8s/deployments/${service}.yaml
        done
        
        # Deploy green environment
        kubectl apply -f k8s/deployments/
    
    - name: Wait for Green Deployment
      run: |
        kubectl rollout status deployment/product-service -n ecommerce --timeout=10m
        kubectl rollout status deployment/user-service -n ecommerce --timeout=10m
        kubectl rollout status deployment/cart-service -n ecommerce --timeout=10m
        kubectl rollout status deployment/order-service -n ecommerce --timeout=10m
    
    - name: Run Production Smoke Tests
      run: |
        LB_URL=$(kubectl get ingress ecommerce-ingress -n ecommerce -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Health checks
        curl -f http://${LB_URL}/api/products/health || exit 1
        curl -f http://${LB_URL}/api/users/health || exit 1
        curl -f http://${LB_URL}/api/cart/health || exit 1
        curl -f http://${LB_URL}/api/orders/health || exit 1
        
        echo "Production smoke tests passed!"
    
    - name: Label Green as Production
      run: |
        kubectl label deployment/product-service -n ecommerce version=production --overwrite
        kubectl label deployment/user-service -n ecommerce version=production --overwrite
        kubectl label deployment/cart-service -n ecommerce version=production --overwrite
        kubectl label deployment/order-service -n ecommerce version=production --overwrite
    
    - name: Notify Deployment Success
      if: success()
      run: |
        echo "Production deployment successful for version ${{ github.ref_name }}"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-to-production]
    if: failure()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
    
    - name: Rollback Deployment
      run: |
        kubectl rollout undo deployment/product-service -n ecommerce
        kubectl rollout undo deployment/user-service -n ecommerce
        kubectl rollout undo deployment/cart-service -n ecommerce
        kubectl rollout undo deployment/order-service -n ecommerce
    
    - name: Notify Rollback
      run: |
        echo "Deployment failed. Rolled back to previous version."
