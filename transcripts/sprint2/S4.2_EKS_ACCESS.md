# S4.2: EKS Access Configuration

**Video Duration:** ~8 minutes  
**Story Points:** 2

---

## Learning Objectives

By the end of this video, you will be able to:
- Understand EKS authentication methods
- Configure Access Entries (new API)
- Set up aws-auth ConfigMap (legacy)
- Grant team members cluster access

---

## Transcript

### Introduction (0:00 - 1:00)

Welcome back! We have a running cluster, but who can access it? Right now, only the IAM identity that created the cluster has admin access.

Let's configure proper access for our team.

### EKS Authentication Methods (1:00 - 2:30)

EKS has two ways to manage access:

**1. Access Entries (New - Recommended)**
- Introduced in 2023
- API-based, Terraform-friendly
- No ConfigMap editing

**2. aws-auth ConfigMap (Legacy)**
- Been around since EKS launched
- Editing a ConfigMap in kube-system
- Can be error-prone

We'll focus on Access Entries, but I'll show both.

### Configuring Access Entries (2:30 - 5:00)

```hcl
resource "aws_eks_access_entry" "admin" {
  cluster_name  = aws_eks_cluster.main.name
  principal_arn = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/Admin"
  type          = "STANDARD"
}

resource "aws_eks_access_policy_association" "admin" {
  cluster_name  = aws_eks_cluster.main.name
  principal_arn = aws_eks_access_entry.admin.principal_arn
  policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"

  access_scope {
    type = "cluster"
  }
}
```

This grants the Admin role full cluster access.

For developers, you might use a more restricted policy:

```hcl
resource "aws_eks_access_entry" "developer" {
  cluster_name  = aws_eks_cluster.main.name
  principal_arn = "arn:aws:iam::ACCOUNT:role/Developer"
  type          = "STANDARD"
}

resource "aws_eks_access_policy_association" "developer" {
  cluster_name  = aws_eks_cluster.main.name
  principal_arn = aws_eks_access_entry.developer.principal_arn
  policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSViewPolicy"

  access_scope {
    type       = "namespace"
    namespaces = ["techitfactory"]
  }
}
```

Developers can only view resources in the techitfactory namespace!

### SSO Access (5:00 - 6:30)

If you're using AWS SSO, you need to find the SSO role ARN:

```bash
aws iam list-roles | grep SSO
```

Then add an access entry for that role:

```hcl
resource "aws_eks_access_entry" "sso_admin" {
  cluster_name  = aws_eks_cluster.main.name
  principal_arn = "arn:aws:iam::ACCOUNT:role/aws-reserved/sso.amazonaws.com/AWSReservedSSO_AdministratorAccess_xxxxx"
  type          = "STANDARD"
}
```

### Legacy: aws-auth ConfigMap (6:30 - 7:30)

For reference, here's the legacy approach:

```bash
kubectl edit configmap aws-auth -n kube-system
```

```yaml
mapRoles: |
  - rolearn: arn:aws:iam::ACCOUNT:role/techitfactory-dev-eks-node
    username: system:node:{{EC2PrivateDNSName}}
    groups:
      - system:bootstrappers
      - system:nodes
  - rolearn: arn:aws:iam::ACCOUNT:role/Admin
    username: admin
    groups:
      - system:masters
```

This works, but editing YAML manually is error-prone. I recommend Access Entries.

### Summary (7:30 - 8:00)

We covered:
1. Access Entries - the modern, API-based approach
2. Policy associations for different access levels
3. SSO role configuration
4. Legacy aws-auth ConfigMap

Now your team can access the cluster! Next: Cluster Autoscaler!

---

## Key Takeaways

- Access Entries are the modern, recommended approach
- Different policies for admins vs developers
- SSO roles work with Access Entries
- Namespace-scoped access for least privilege
- aws-auth ConfigMap is legacy but still works
